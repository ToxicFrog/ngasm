--[[
Commands to be implemented:
  peek <range> -- display memory at range
  poke <addr> <value> -- write value to memory
  poke <register> <value> -- write value to register
  list <range> -- disassemble ROM
  where -- display machine state and disassemble code around PC and RAM around A
  break <addr> -- add breakpoint at ROM address
  watch <addr> -- add watchpoint at RAM address
  screen <addr> <w> <h> -- attach raster display
]]
local vm = require "vm"
local vmutil = require 'vmutil'

local commands = {}
local function command(name)
  return function(args)
    return function(desc)
      return function(help)
        commands[name] = {
          name = name;
          fn = nil;
          args = args;
          desc = desc;
          help = help;
        }
      end
    end
  end
end

local function printf(...)
  io.stdout:write(string.format(...))
  io.stdout:flush()
end

local function eprintf(...)
  io.stderr:write(string.format(...))
end

local function run(CPU, line)
  local argv = {}
  for arg in line:gmatch('%S+') do table.insert(argv, arg) end
  local command = table.remove(argv, 1)
  if not command then
    -- do nothing
  elseif commands[command] then
    commands[command].fn(CPU, unpack(argv))
  else
    eprintf('Unrecognized command: %s', command)
  end
end

local function run_shell(CPU)
  -- interactive mode
  printf('Emulator ready. Type "help" for a list of commands.\n> ')
  for line in io.lines() do
    run(CPU, line)
    printf('\n> ')
  end
  print('Goodbye!')
end

function main(CPU, commands)
  if #commands > 0 then
    for _,command in ipairs(commands) do
      run(CPU, command)
    end
  else
    run_shell(CPU)
  end
end

command 'shell' '' 'Enter the interactive shell' [[
  Useless if already in the shell, but can be used from the command line to run
  some startup commands and then drop into the shell.
]]
commands.shell.fn = run_shell

command 'exit' '' 'Exit the emulator' [[
  Does what it says on the tin. You can also press ^D (or ^Z on windows) to exit.
]]
function commands.exit.fn(_) return os.exit(0) end

command 'help' '[command]' 'Display this list, or command-specific help' [[
  With a command or topic, displays the detailed help for it. With no arguments,
  displays a list of all available help topics.
]]
function commands.help.fn(_, name)
  if not name then
    local helplist = {}
    for name,cmd in pairs(commands) do
      table.insert(helplist, cmd)
    end
    table.sort(helplist, function(x,y) return x.name < y.name end)
    for _,cmd in pairs(helplist) do
      eprintf('%16s\x1B[0m %-24s  %s\n', '\x1B[4m'..cmd.name, cmd.args, cmd.desc)
    end
  else
    local cmd = commands[name]
    eprintf('%16s %-24s  %s\x1B[0m\n\n', '\x1B[4m'..cmd.name, cmd.args, cmd.desc)
    eprintf('%s\n', cmd.help)
  end
end

command 'flash' '</path/to/rom[.hex]>' 'Load a new program into ROM' [[
  Loads the contents of the given file as a ROM. If the file ends in .hex it
  is assumed to be a human-readable hex dump of the ROM; both plain hex dumps
  and those generated by xxd(1) are supported. In any other case the ROM is
  assumed to be a binary file containing big-endian bytecode and is loaded as
  is.
]]
function commands.flash.fn(CPU, path)
  local data = assert(io.open(path)):read('*a')
  if path:match('%.hex$') then
    if not data:match("[^0-9A-Fa-f%s]") then
      -- file consists only of hex digits and whitespace, assume plain hexdump
      data = vmutil.hex2bin(data)
    else
      -- assume xxd hexdump
      data = vmutil.xxd2bin(data)
    end
  else
    assert(#data % 2 == 0, "ROM image has an odd number of bytes")
  end
  CPU:flash(data)
  eprintf("Flashed %d words to ROM. Read %d debug symbols.\n", #CPU.rom, #CPU.symbols)
end

command 'source' '</path/to/source.asm>' 'Load source code for debugging' [[
  Loads the given file as the source code for the currently loaded ROM. In trace
  mode, it will consult this file to attempt to figure out how to label offsets
  in the ROM.
]]
function commands.source.fn(CPU, path)
  CPU:source(path)
  local nlabels = 0
  for _,sym in ipairs(CPU.symbols) do
    if sym.name then nlabels = nlabels + 1 end
  end
  eprintf("Loaded %s as source code. Identified %d labels.\n", path, nlabels)
end

command 'reset' '' 'Reset the emulator' [[
  Resets the CPU, reinitializing all memory and registers to 0. Does not
  clear ROM.
]]
commands.reset.fn = vm.reset

command 'run' '' 'Run the program to completion' [[
  Starts the emulator and runs the program in ROM until it exits (by jumping
  to a location past the end of ROM).
]]
function commands.run.fn(CPU)
  CPU:trace(nil, function(CPU)
    if CPU.CLK % 1024 == 0 then
      io.stderr:write('\r'..tostring(CPU)..'\x1B[K')
    end
  end)
  io.stderr:write('\n')
end

command 'trace' '' 'Run the program while printing CPU state' [[
  As run, but after executing each instruction, prints out the contents of the
  registers, the word in memory pointed at by the A register, and the just-
  executed and next-to-be-executed instructions.
]]
commands.trace.fn = vm.trace

command 'break' '[addr]' 'Set or remove a breakpoint' [[
  Sets a breakpoint at the given address. When encountered by 'run' or 'trace',
  it will drop back into the shell. 'break' with no arguments lists all
  breakpoints. 'break' with an address that already has a breakpoint removes it.
]]
commands['break'].fn = function(CPU, address)
  if address then
    address = tonumber(address)
    local set = CPU:toggle_breakpoint(address)
    eprintf('%s breakpoint at address $%04X\n',
      set and "Added" or "Removed", address)
  else
    for addr,enabled in pairs(CPU.breakpoints) do
      if enabled then
        local op = vmutil.decode(CPU.rom[addr])
        printf('%04X - $%-32s %s\n',
          addr, tostring(op), CPU:pc_to_source(addr))
      end
    end
  end
end

command 'file' 'path address [mode]' 'Attach a file to the emulator' [[
  Attaches a file for byte-by-byte or word-by-word IO. It is mapped at the
  given address and the subsequent two addresses; see iostream.lua for
  details of how program code can access it. If not specified the mode
  defaults to rb (read only).
]]
function commands.file.fn(CPU, path, address, mode)
  mode = mode or 'rb'
  address = tonumber(address)
  CPU:attach(address, require('iostream').new(path, mode))
end

command 'info' '' 'Display emulated CPU state' [[
  Outputs a line containing the current state of the emulated CPU. This is the
  same output format used by 'trace'.
]]
function commands.info.fn(CPU)
  eprintf('%s\n', CPU)
end

command 'stack' '' 'Display stack information' [[
  Outputs information about the software stack and the pseudo-registers in
  RAM that hold information about it.
]]
function commands.stack.fn(CPU)
  local SP = CPU.ram[0]
  eprintf('SP: %04X   ARGS: %04X   LOCALS: %04X   RETURN: %04X\n',
    SP, CPU.ram[1], CPU.ram[2], CPU.ram[CPU.ram[2]-1] or 0)

  local base = SP - (SP % 0x1000) -- guess at stack base
  for i=0,SP - base - 1 do
    eprintf('$%04X:stack[%d]  %04X\n', base+i, i, CPU.ram[base+i])
  end
end

command 'step' '' 'Step the CPU one instruction' [[
  Executes one instruction and then outputs the state of the CPU. Equivalent
  to a one-cycle 'trace'.
]]
function commands.step.fn(CPU)
  CPU:step()
  printf('%s\n', CPU)
end

command 'watch' 'address' 'Watch for changes to a memory address' [[
  Watches for changes to a memory address. Whenever the value at the address
  changes, it outputs the state of the CPU afterwards.
]]
function commands.watch.fn(CPU, address)
  CPU:add_watch(tonumber(address))
end

command 'symbols' '' 'List the contents of the symbol table' [[
  Displays the contents of the debug symbol table, if any, in the format:
    %hash $address name
]]
function commands.symbols.fn(CPU)
  -- TODO: include line number information where available
  printf(' \x1b[4m%5s ┊ %5s ┊ %s\x1b[0m\n', 'ID', 'VAL', 'Name')
  for _,sym in ipairs(CPU.symbols) do
    printf(' %5d ┊ $%04X ┊ %s\n', sym.hash, sym.addr, sym.name or '')
  end
end

command 'list' '' 'Disassemble the loaded ROM' [[
  Disassembles the contents of ROM. Each line has the format:
    RRRR - $IIII [desc]    :Label+n
  Where R is the ROM address, I the underlying opcode, desc the human-
  readable description of the operation, label the most recent label in
  the source code, and +n the number of words of ROM past that label we
  are. Label information is only available if the source code is loaded
  (with the "source" command) and the ROM contains a symbol table.
]]
function commands.list.fn(CPU)
  for addr=0, #CPU.rom do
    local word = CPU.rom[addr]
    local src = CPU:pc_to_source(addr)
    if not src:match('%+%d+$') then
      printf('\n%04X         %s\n', addr, src)
    end
    local op = vmutil.decode(word)
    if not op.is_nop then
      printf('%04X - $%-32s\n', addr, tostring(op))
    end
  end
end

return { main=main }
