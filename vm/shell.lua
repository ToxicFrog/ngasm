--[[
Commands to be implemented:
  peek <range> -- display memory at range
  poke <addr> <value> -- write value to memory
  poke <register> <value> -- write value to register
  list <range> -- disassemble ROM
  where -- display machine state and disassemble code around PC and RAM around A
  break <addr> -- add breakpoint at ROM address
  watch <addr> -- add watchpoint at RAM address
  screen <addr> <w> <h> -- attach raster display
]]
local vm = require "vm"
local vmutil = require 'vmutil'

local commands = {}
local function command(name)
  return function(args)
    return function(desc)
      return function(help)
        commands[name] = {
          name = name;
          fn = nil;
          args = args;
          desc = desc;
          help = help;
        }
      end
    end
  end
end

local function printf(...)
  io.stdout:write(string.format(...))
  io.stdout:flush()
end

local function eprintf(...)
  io.stderr:write(string.format(...))
end

local function run(CPU, line)
  local argv = {}
  for arg in line:gmatch('%S+') do table.insert(argv, arg) end
  local command = table.remove(argv, 1)
  if not command then
    -- do nothing
  elseif commands[command] then
    commands[command].fn(CPU, unpack(argv))
  else
    eprintf('Unrecognized command: %s', command)
  end
end

local function run_shell(CPU)
  -- interactive mode
  printf('Emulator ready. Type "help" for a list of commands.\n> ')
  for line in io.lines() do
    local _,err = pcall(run, CPU, line)
    if err then
      eprintf('Error in command: %s', err)
    end
    printf('\n> ')
  end
  print('Goodbye!')
end

function main(CPU, commands)
  if #commands > 0 then
    for _,command in ipairs(commands) do
      run(CPU, command)
    end
  else
    run_shell(CPU)
  end
end

command 'shell' '' 'Enter the interactive shell' [[
  Useless if already in the shell, but can be used from the command line to run
  some startup commands and then drop into the shell.
]]
commands.shell.fn = run_shell

command 'exit' '' 'Exit the emulator' [[
  Does what it says on the tin. You can also press ^D (or ^Z on windows) to exit.
]]
function commands.exit.fn(_) return os.exit(0) end

command 'help' '[command]' 'Display this list, or command-specific help' [[
  With a command or topic, displays the detailed help for it. With no arguments,
  displays a list of all available help topics.
]]
function commands.help.fn(_, name)
  if not name then
    local helplist = {}
    for name,cmd in pairs(commands) do
      table.insert(helplist, cmd)
    end
    table.sort(helplist, function(x,y) return x.name < y.name end)
    for _,cmd in pairs(helplist) do
      eprintf('%16s\x1B[0m %-24s  %s\n', '\x1B[4m'..cmd.name, cmd.args, cmd.desc)
    end
  else
    local cmd = commands[name]
    eprintf('%16s %-24s  %s\x1B[0m\n\n', '\x1B[4m'..cmd.name, cmd.args, cmd.desc)
    eprintf('%s\n', cmd.help)
  end
end

command 'flash' '</path/to/rom[.hex]>' 'Load a new program into ROM' [[
  Loads the contents of the given file as a ROM. If the file ends in .hex it
  is assumed to be a human-readable hex dump of the ROM; both plain hex dumps
  and those generated by xxd(1) are supported. In any other case the ROM is
  assumed to be a binary file containing big-endian bytecode and is loaded as
  is.
]]
function commands.flash.fn(CPU, path)
  local data = assert(io.open(path)):read('*a')
  if path:match('%.hex$') then
    if not data:match("[^0-9A-Fa-f%s]") then
      -- file consists only of hex digits and whitespace, assume plain hexdump
      data = vmutil.hex2rom(data)
    else
      -- assume xxd hexdump
      data = vmutil.xxd2rom(data)
    end
  else
    assert(#data % 2 == 0, "ROM image has an odd number of bytes")
  end
  CPU:flash(data)
  eprintf("Flashed %d words to ROM.\n", #CPU.rom+1)
end

command 'source' '</path/to/source.asm>' 'Load source code for debugging' [[
  Loads the given file as the source code for the currently loaded ROM. In trace
  mode, it will consult this file to attempt to figure out how to label offsets
  in the ROM.
]]
function commands.source.fn(CPU, path)
  CPU.debug:source_file(path)
  local nlabels = 0
  for _,sym in ipairs(CPU.debug.symbols) do
    if sym.name then nlabels = nlabels + 1 end
  end
  eprintf("Loaded %s as source code. Found %d symbols with %d names.\n",
    path, #CPU.debug.symbols, nlabels)
end

command 'reset' '' 'Reset the emulator' [[
  Resets the CPU, reinitializing all memory and registers to 0. Does not
  clear ROM.
]]
commands.reset.fn = vm.reset

command 'run' '[count]' 'Run the program' [[
  Starts the emulator and runs the program until [count] instructions have been
  dispatched (including nops). If [count] is unspecified, runs until the program
  exits (by jumping past the end of ROM).
]]
function commands.run.fn(CPU, count)
  CPU:trace(tonumber(count) or math.huge, function(CPU)
    -- if CPU.CLK % 8192 == 0 then
    --   io.stderr:write('\r'..tostring(CPU)..'\x1B[K')
    -- end
  end)
  -- io.stderr:write('\n')
end

command 'trace' '[count]' 'Run the program while printing CPU state' [[
  This is equivalent to 'run', but prints the machine state after each one.
  This consists of the address and value of the just-executed opcode, its
  disassembly, the number of ops executed since boot, both registers, the
  contents of memory pointed to by the A register, and the address of the next
  instruction to be executed.
  Where symbol table information is available, it also prints the label of the
  instruction just executed.
]]
function commands.trace.fn(CPU, count)
  CPU:trace(tonumber(count) or math.huge)
end

command 'break' '[addr]' 'Set or remove a breakpoint' [[
  Sets a breakpoint at the given address. When encountered by 'run' or 'trace',
  it will drop back into the shell. 'break' with no arguments lists all
  breakpoints. 'break' with an address that already has a breakpoint removes it.
]]
commands['break'].fn = function(CPU, address)
  if address then
    address = CPU.debug:to_address(address, 'rom')
    local set = CPU.debug:toggle_breakpoint(address)
    eprintf('%s breakpoint at address $%04X\n',
      set and "Added" or "Removed", address)
  else
    for addr,enabled in pairs(CPU.debug.breakpoints) do
      if enabled then
        local op = CPU:decode(addr)
        printf('%04X - $%-32s %s\n',
          addr, CPU.debug:op_to_string(op), CPU.debug:pc_to_label(addr))
      end
    end
  end
end

command 'file' 'path address [mode]' 'Attach a file to the emulator' [[
  Attaches a file for byte-by-byte or word-by-word IO. It is mapped at the
  given address and the subsequent two addresses; see iostream.lua for
  details of how program code can access it. If not specified the mode
  defaults to rb (read only).
]]
function commands.file.fn(CPU, path, address, mode)
  mode = mode or 'rb'
  address = tonumber(address)
  CPU:attach(address, require('iostream').new(path, mode))
end

command 'info' '' 'Display emulated CPU state' [[
  Outputs a line containing the current state of the emulated CPU. This is the
  same output format used by 'trace'.
]]
function commands.info.fn(CPU)
  eprintf('%s\n', CPU)
end

command 'stack' '' 'Display stack information' [[
  Outputs information about the software stack and the pseudo-registers in
  RAM that hold information about it.
]]
function commands.stack.fn(CPU)
  local SP = CPU.ram[0]
  eprintf('SP: %04X   ARGS: %04X   LOCALS: %04X   RETURN: %04X\n',
    SP, CPU.ram[1], CPU.ram[2], CPU.ram[CPU.ram[2]-1] or 0)

  local base = SP - (SP % 0x1000) -- guess at stack base
  for i=0,SP - base - 1 do
    eprintf('$%04X:stack[%d]  %04X\n', base+i, i, CPU.ram[base+i])
  end
end

command 'step' '' 'Step the CPU one instruction' [[
  Executes one instruction and then outputs the state of the CPU. Equivalent
  to a one-cycle 'trace'.
]]
function commands.step.fn(CPU)
  CPU:step()
  printf('%s\n', CPU)
end

command 'watch' '[address]' 'Watch for changes to a memory address' [[
  Watches for changes to a memory address. Whenever the value at the address
  changes, it outputs the state of the CPU afterwards. Register names are
  allowed and will watch whatever that register points at.

  With no arguments, lists all watches. With the address of an existing watch,
  removes it.
]]
function commands.watch.fn(CPU, address)
  if address then
    address = CPU.debug:to_address(address, 'ram')
    local set = CPU.debug:toggle_watch(address)
    eprintf('%s watch on RAM address $%04X\n',
      set and "Added" or "Removed", address)
  else
    for addr,value in pairs(CPU.debug.watches) do
      printf('%04X - $%04X\n', addr, value)
    end
  end
end

local function sym_value(sym)
  if sym.type == 'rom' then
    return string.format('ROM $%04X', sym.value)
  elseif sym.type == 'ram' then
    return string.format('RAM $%04X', sym.value)
  elseif sym.type == 'constant' then
    return string.format('0x%04X', sym.value)
  elseif sym.type == 'macro' then
    return string.format('fp:%d', sym.value)
  else
    return tostring(sym.value)
  end
end

command 'symbols' '' 'List the contents of the symbol table' [[
  Displays the contents of the debug symbol table, if any, in the format:
    %hash $address name
]]
function commands.symbols.fn(CPU)
  -- TODO: include line number information where available
  printf(' \x1b[4m%-4s ┊ %-5s ┊ %-9s ┊ %s\x1b[0m\n', 'Line', 'ID', 'Value', 'Name')
  for _,sym in ipairs(CPU.debug.symbols) do
    printf(' %4d ┊ %5d ┊ %9s ┊ %s\n', sym.line, sym.id, sym_value(sym), sym.name or '')
  end
end

command 'list' '[address] [size]' 'Disassemble the loaded ROM' [[
  Disassembles the contents of ROM.

  [address] is the ROM address to start at; it can be any numeric address, or
  the name of a register (A, D, or PC) for the value held in that register. The
  default if unspecified is 'PC'.

  [size] is the number of instructions to disassemble. Note that, since no-ops
  are skipped, fewer instructions may be displayed. You can also specify 'this'
  to disassemble to the next ROM label, or 'all' to disassemble to the end of
  ROM. The default is 'this'.

  Instructions have the format:
    RRRR - $IIII | asm | annotation
  Where R is the ROM address, I the underlying opcode, asm the human-readable
  form, and annotation additional information such as the jump type (for jumps)
  or alternate data representations (for constants).

  If a symbol table is present in the ROM and the source code was loaded, labels
  will additionally get their own lines.
]]
function commands.list.fn(CPU, address, size)
  address = CPU.debug:to_address(address or 'pc', 'rom')
  local to_ret = not size or size == 'this'
  size = tonumber(size) or math.huge

  for addr,type,info in CPU.debug:disassemble(address, size) do
    if type == 'label' then
      if addr ~= address and to_ret then break end
      printf('\n%04X         %s\n', addr, info)
    elseif not info.is_nop then
      printf('%04X - $%-32s\n', addr, CPU.debug:op_to_string(info, true))
    end
  end
end

command 'peek' 'address [size]' 'Display memory' [[
  Displays the contents of RAM.

  With no size, displays the word at the given address. With size, displays the
  [size] words starting at the given address.
]]
function commands.peek.fn(CPU, address, size)
  size = size or 1
  address = CPU.debug:to_address(address, 'ram')
  for i=0,size-1 do
    printf('%04X - $%04X\n', address+i, CPU.ram[address+i])
  end
end

return { main=main }
