This directory holds the various stages of the self-hosted toolchain. This is
visible in the git history, but this displays it in a somewhat more convenient
manner.

In general, it follows a pattern where even-numbered versions implement new
features (starting at stage 0 which implements the first version of the
assembler itself), while odd-numbered versions refactor or completely rewrite
the assembler to take advantage of those new features without changing the actual
functionality of the assembler.

The three file types contained herein are:
- `.asm`: the source code for that version of the assembler
- `.hex`: the ROM image generated from the source code, in `xxd` format
- `.md`: the documentation for that version of the assembler

If a given version has no `.md` file, that means the behaviour, and thus the
documentation, hasn't changed since the previous version.

Some versions may have a directory full of `.asm` files; in that case these are
the recommended form in which to edit the source, and the top-level `.asm` file
is just a concatenation of these files to feed to the compiler.

## 00 - Simple Assembler (nandgame syntax)

This is the first version of the assembler. It's designed to be straightforward
and easy to follow, not necessarily compact, efficient, or easy to upgrade. This
version was written in the syntax understood by the in-browser assembler used by
[NANDgame](https://www.nandgame.com/), which is not the same syntax it
understands itself -- this let me use nandgame to assemble it, rather than doing
what I would have needed to do in a true "self hosting from scratch" situation,
i.e. write it out on paper and assemble it to machine code using a pencil and a
copy of the processor reference manual.

## 01 - Simple Assembler (ngasm syntax)

This is a 1:1 translation of the above into the syntax that it itself understands.
This is thus the first version of the assembler that you can feed to itself.

It is fairly hard to follow due to the lack of support for defines and labels; the
overall program structure and algorithm are identical to the nandgame-syntax
version, so I recommend reading that instead to understand how it works.

The hex file was generated by feeding this source code into the stage 0 ROM to
produce the stage 1 ROM, then feeding it again into the stage 1 ROM -- which
produced identical output, confirming that the translation from nandgame syntax
to ngasm syntax was correct and did not affect its behaviour.

In the process of making this translation, I also found a few bugs in the stage 0
code -- two places where it jumped to the wrong label, one where it was setting
the wrong bit in the opcode, and one where it was checking for the wrong input
character. In the interests of versimilitude I fixed these by editing the .hex
file for the stage 0 ROM by hand rather than by re-assembling it with the nandgame
assembler. :)

# 02 - Label Support

This version adds support for labels. It is fairly basic and ugly but it frees
me from the tyranny of having to manually calculate my jump destinations and is
thus an absolutely massive quality of life improvement.

Since stage 1 does *not* support labels, this version had to be written without
them. This meant that I couldn't move any existing code without needing to
recalculate all the jumps, which is a tedious and error-prone process; instead
I added all of the new code at the end and just overwrote some code near the
start with jumps to it.

The symbol table is stored as an array of `[ symbol, value ]` pairs, each entry
taking up two adjacent words. In the interest of not dealing with strings, the
"symbol" is actually a simple hash computed from the characters of the symbol as
the source code was read, using the function:
```
  hash(str[0]) = str[0]
  hash(str[n]) = (hash(str[n-1]) << 1) + str[n]
```
The shift makes it ordering-sensitive (so that `foo` and `oof` won't have the
same hash) but also means that when hashing symbols longer than 16 characters,
only the last 16 will affect the hash.

# 03 - Label Refactoring

This has the same behaviour as stage 2, but rewrites the code to make use of
labels, replacing hard-coded jump targets. This means I can finally rearrange
the source code without worrying about recalculating my jumps!

It also uses labels as ersatz defines, for variable addresses where we don't
care exactly where in memory they reside, just that they have unique addresses.
Since the assembler still outputs 1 instruction per line, even on blank lines,
each label will have a unique address.

# 04 - Constants and Macros

This brings a major expansion in capabilities. To support this, the code for
reading constants and symbols is pulled out into reusable procedures, which can
be called from anywhere in the program and passed a continuation to call once
finished.

The literal reader drops support for octal and replaces it with support for
decimal, hexadecimal, and character literals. It can also delegate to the symbol
reader if it encounters a symbol where a literal was expected.

The symbol reader adds support for symbols starting with `#` or `&`, and removes
the requirement that all symbols end with `.`.

Constant support is added as a new parser branch, accessed by starting a line with
`#` or `&`; by following the symbol with an `=` and then a value, you can bind
names to arbitrary values.

Very primitive error reporting is added, with the ability of the compiler to
report the line number it was processing when it errored out.

Finally, the big new feature is macro support; macros can be defined as sequences
of instructions, including arguments that can be provided at the call site and
which are spliced into the body of the macro at evaluation time. Macros are not
functions; they are evaluated during compilation and emit instructions directly
into the generated binary at the point where they are called.

Internally, this is implemented by recording, as the value of each macro, the
offset in the file at which the macro starts. When a call to the macro is
encountered, the current file offset is saved, and the input file is rewound to
the point in the file where the macro starts. The contents of the macro are thus
processed and output as if they occurred in the file at the point where the macro
call is, and once the end of the macro definition is reached, the saved file
offset is restored.
