This directory holds the various stages of the self-hosted toolchain. This is
visible in the git history, but this displays it in a somewhat more convenient
manner.

In general, it follows a pattern where even-numbered versions implement new
features (starting at stage 0 which implements the first version of the
assembler itself), while odd-numbered versions refactor or completely rewrite
the assembler to take advantage of those new features without changing the actual
functionality of the assembler.

The three file types contained herein are:
- `.asm`: the source code for that version of the assembler
- `.hex`: the ROM image generated from the source code, in `xxd` format
- `.md`: the documentation for that version of the assembler

If a given version has no `.md` file, that means the behaviour, and thus the
documentation, hasn't changed since the previous version.

## 00 - Simple Assembler (nandgame syntax)

This is the first version of the assembler. It's designed to be straightforward
and easy to follow, not necessarily compact, efficient, or easy to upgrade. This
version was written in the syntax understood by the in-browser assembler used by
[NANDgame](https://www.nandgame.com/), which is not the same syntax it
understands itself -- this let me use nandgame to assemble it, rather than doing
what I would have needed to do in a true "self hosting from scratch" situation,
i.e. write it out on paper and assemble it to machine code using a pencil and a
copy of the processor reference manual.

## 01 - Simple Assembler (ngasm syntax)

This is a 1:1 translation of the above into the syntax that it itself understands.
This is thus the first version of the assembler that you can feed to itself.

It is fairly hard to follow due to the lack of support for defines and labels; the
overall program structure and algorithm are identical to the nandgame-syntax
version, so I recommend reading that instead to understand how it works.

The hex file was generated by feeding this source code into the stage 0 ROM to
produce the stage 1 ROM, then feeding it again into the stage 1 ROM -- which
produced identical output, confirming that the translation from nandgame syntax
to ngasm syntax was correct and did not affect its behaviour.

In the process of making this translation, I also found a few bugs in the stage 0
code -- two places where it jumped to the wrong label, one where it was setting
the wrong bit in the opcode, and one where it was checking for the wrong input
character. In the interests of versimilitude I fixed these by editing the .hex
file for the stage 0 ROM by hand rather than by re-assembling it with the nandgame
assembler. :)

# 02 - Label Support

This version adds support for labels. It is fairly basic and ugly but it frees
me from the tyranny of having to manually calculate my jump destinations and is
thus an absolutely massive quality of life improvement.

Since stage 1 does *not* support labels, this version had to be written without
them. This meant that I couldn't move any existing code without needing to
recalculate all the jumps, which is a tedious and error-prone process; instead
I added all of the new code at the end and just overwrote some code near the
start with jumps to it.

The symbol table is stored as an array of `[ symbol, value ]` pairs, each entry
taking up two adjacent words. In the interest of not dealing with strings, the
"symbol" is actually a simple hash computed from the characters of the symbol as
the source code was read, using the function:
```
  hash(str[0]) = str[0]
  hash(str[n]) = (hash(str[n-1]) << 1) + str[n]
```
The shift makes it ordering-sensitive (so that `foo` and `oof` won't have the
same hash) but also means that when hashing symbols longer than 16 characters,
only the last 16 will affect the hash.

# 03 - Label Refactoring

This has the same behaviour as stage 2, but rewrites the code to make use of
labels, replacing hard-coded jump targets. This means I can finally rearrange
the source code without worrying about recalculating my jumps!

It also uses labels as ersatz defines, for variable addresses where we don't
care exactly where in memory they reside, just that they have unique addresses.
Since the assembler still outputs 1 instruction per line, even on blank lines,
each label will have a unique address.

# 04 - Defines and Syntax Tidying

This is planned to bring a number of reader improvements:
- decimal constants by default
- $ff for hex constants
- 'a for character constants
- no terminating . needed on labels
- &foo 1 and #foo 1 for arbitrary-value defines
- strip nops from output

# 06 - Macros

This version will hopefully bring macro support, the ability the bind a symbol
to a sequence of instructions. The first version will probably not support
arguments, but that still gives us the starting rudiments of a stack:
initsp pusha pushd popa popd add sub, the various logical operators, and
possibly even versions of call/return that operate entirely from the stack
rather than from arguments.

# 08 - Stack Language

Maybe we implement an itty bitty forth?
