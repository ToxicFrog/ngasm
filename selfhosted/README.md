This directory holds the various stages of the self-hosted toolchain. This is
visible in the git history, but this displays it in a somewhat more convenient
manner.

In general, it follows a pattern where even-numbered versions implement new
features (starting at stage 0 which implements the first version of the
assembler itself), while odd-numbered versions refactor or completely rewrite
the assembler to take advantage of those new features without changing the actual
functionality of the assembler.

## 00 - Simple Assembler (nandgame syntax)

This is the first version of the assembler. It's designed to be straightforward
and easy to follow, not necessarily compact, efficient, or easy to upgrade. This
version was written in the syntax understood by the in-browser assembler used by
[NANDgame](https://www.nandgame.com/), which is not the same syntax it
understands itself -- this let me use nandgame to assemble it, rather than doing
what I would have needed to do in a true "self hosting from scratch" situation,
i.e. write it out on paper and assemble it to machine code using a pencil and a
copy of the processor reference manual.

## 01 - Simple Assembler (ngasm syntax)

This is a 1:1 translation of the above into the syntax that it itself understands.
This is thus the first version of the assembler that you can feed to itself.

It is fairly hard to follow due to the lack of support for defines and labels; the
overall program structure and algorithm are identical to the nandgame-syntax
version, so I recommend reading that instead to understand how it works.

The hex file was generated by feeding this source code into the stage 0 ROM to
produce the stage 1 ROM, then feeding it again into the stage 1 ROM -- which
produced identical output, confirming that the translation from nandgame syntax
to ngasm syntax was correct and did not affect its behaviour.

In the process of making this translation, I also found a few bugs in the stage 0
code -- two places where it jumped to the wrong label, one where it was setting
the wrong bit in the opcode, and one where it was checking for the wrong input
character. In the interests of versimilitude I fixed these by editing the .hex
file for the stage 0 ROM by hand rather than by re-assembling it with the nandgame
assembler. :)

# 02 - Label Support

This version adds support for labels. It is fairly basic and ugly but it frees
me from the tyranny of having to manually calculate my jump destinations and is
thus an absolutely massive quality of life improvement.

Since stage 1 does *not* support labels, this version had to be written without
them. This meant that I couldn't move any existing code without needing to
recalculate all the jumps, which is a tedious and error-prone process; instead
I added all of the new code at the end and just overwrote some code near the
start with jumps to it.

The symbol table is stored as an array of `[ symbol, value ]` pairs, each entry
taking up two adjacent words. In the interest of not dealing with strings, the
"symbol" is actually a simple hash computed from the characters of the symbol as
the source code was read, using the function:
```
  hash(str[0]) = str[0]
  hash(str[n]) = (hash(str[n-1]) << 1) + str[n]
```
The shift makes it ordering-sensitive (so that `foo` and `oof` won't have the
same hash) but also means that when hashing symbols longer than 16 characters,
only the last 16 will affect the hash.
