--[[
baseline commands we absolutely need:
  flash in out reset run exit
useful debugging commands:
  peek poke list where break trace watch step
fancy stuff:
  screen
]]
local vm = require "vm"

local commands = {}
local function command(name)
  return function(args)
    return function(desc)
      return function(help)
        commands[name] = {
          name = name;
          fn = nil;
          args = args;
          desc = desc;
          help = help;
        }
      end
    end
  end
end

local function printf(...)
  return io.stdout:write(string.format(...))
end

local function run(CPU, line)
  local argv = {}
  for arg in line:gmatch('%S+') do table.insert(argv, arg) end
  local command = table.remove(argv, 1)
  if not command then
    -- do nothing
  elseif commands[command] then
    commands[command].fn(CPU, unpack(argv))
  else
    print('Unrecognized command: '..command)
  end
end

function main(CPU, commands)
  if #commands > 0 then
    for _,command in ipairs(commands) do
      run(CPU, command)
    end
  else
    -- interactive mode
    io.stdout:write('Emulator ready. Type "help" for a list of commands.\n> ')
    io.stdout:flush()
    for line in instructions(commands) do
      run(CPU, line)
      io.stdout:write('\n> ')
      io.stdout:flush()
    end
  end
  print('Goodbye!')
end

command 'exit' '' 'Exit the emulator' [[
  Does what it says on the tin. You can also press ^D (or ^Z on windows) to exit.
]]
function commands.exit.fn(_) return os.exit(0) end

command 'help' '[command]' 'Display this list, or command-specific help' [[
  With a command or topic, displays the detailed help for it. With no arguments,
  displays a list of all available help topics.
]]
function commands.help.fn(_, name)
  if not name then
    local helplist = {}
    for name,cmd in pairs(commands) do
      table.insert(helplist, cmd)
    end
    table.sort(helplist, function(x,y) return x.name < y.name end)
    for _,cmd in pairs(helplist) do
      printf('%12s %-24s  %s\n', '\x1B[4m'..cmd.name..'\x1B[0m', cmd.args, cmd.desc)
    end
  else
    local cmd = commands[name]
    printf('\x1B[4m%12s %-24s  %s\x1B[0m\n', cmd.name, cmd.args, cmd.desc)
    print()
    print(cmd.help)
  end
end

local function hex2bin(data)
  local rom = {}
  local ptr = 0
  data = data:gsub("%s+", "") -- remove all whitespace
  assert(#data % 4 == 0, "ROM image has an odd number of bytes")
  for word in data:gmatch("%x%x%x%x") do
    rom[ptr] = tonumber(word, 16)
    ptr = ptr + 1
  end
  return rom
end

-- Convert an xxd hexdump into a ROM image.
-- xxd has the following format:
-- AAAAAAAA: XXXX XXXX XXXX XXXX XXXX XXXX XXXX XXXX  ................
-- where A is the address, X is the actual data, and . is the text dump.
local function xxd2bin(data)
  data = data
    :gsub('%x+: +', '')
    :gsub('  .-\n', '')
  return hex2bin(data)
end

command 'flash' '</path/to/rom[.hex]>' 'Load a new program into ROM' [[
  Loads the contents of the given file as a ROM. If the file ends in .hex it
  is assumed to be a human-readable hex dump of the ROM; both plain hex dumps
  and those generated by xxd(1) are supported. In any other case the ROM is
  assumed to be a binary file containing big-endian bytecode and is loaded as
  is.
]]
function commands.flash.fn(CPU, path)
  local data = assert(io.open(path)):read('*a')
  if path:match('%.hex$') then
    if not data:match("[^0-9A-Fa-f%s]") then
      -- file consists only of hex digits and whitespace, assume plain hexdump
      data = hex2bin(data)
    else
      -- assume xxd hexdump
      data = xxd2bin(data)
    end
    CPU:flash(data)
    printf("Flashed %d words to ROM.\n", #data+1)
  else
    assert(#data % 2 == 0, "ROM image has an odd number of bytes")
    CPU:flash(data)
    printf("Flashed %d words to ROM.\n", #data/2)
  end
end

command 'reset' '' 'Reset the emulator' [[
  Resets the CPU, reinitializing all memory and registers to 0. Does not
  clear ROM.
]]
commands.reset.fn = vm.reset

command 'run' '' 'Run the program to completion' [[
  Starts the emulator and runs the program in ROM until it exits (by jumping
  to a location past the end of ROM).
]]
commands.run.fn = vm.run

command 'trace' '' 'Run the program while printing CPU state' [[
  As run, but after executing each instruction, prints out the contents of the
  registers, the word in memory pointed at by the A register, and the just-
  executed and next-to-be-executed instructions.
]]
commands.trace.fn = vm.trace

command 'file' 'path address [mode]' 'Attach a file to the emulator' [[
  Attaches a file for byte-by-byte or word-by-word IO. It is mapped at the
  given address and the subsequent two addresses; see iostream.lua for
  details of how program code can access it. If not specified the mode
  defaults to rb (read only).
]]
function commands.file.fn(CPU, path, address, mode)
  mode = mode or 'rb'
  address = tonumber(address)
  CPU:attach(address, require('iostream').new(path, mode))
end


return { main=main }
